/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package com.compi.scanner;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.compi.scanner.semantico.*;
import com.compi.scanner.traductor.*;


parser code {:
    private Symbol sym;

    public void syntax_error(Symbol sym) {
        System.err.println("Error sintáctico en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void unrecovered_syntax_error(Symbol sym) {
        System.err.println("Error irreparable en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void semantic_error(Symbol sym) {
        System.err.println("Error semántico en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void report_error(String message) {
        System.err.println(message);
    }
        
    public Symbol getS(){
        return this.sym;
    };

    public Generador generador = new Generador();

    // Métodos para la tabla de símbolos
    private TablaSimbolos ts = new TablaSimbolos();
    public PilaSemantica pilaSemantica = new PilaSemantica();

    public void imprimirTablasSimbolos() {
        ts.imprimirTablas();
    }

    // Acciones Semanticas

    public void recuerdaTipo(String tipo) {
        RS_TIPO rs_tipo = new RS_TIPO(tipo);
        pilaSemantica.push(rs_tipo);
    }

    public void recuerdaID(String id) {
        RS_ID rs_id = new RS_ID(id);
        pilaSemantica.push(rs_id);
    }

    public void insertarTS() {
        // buscar RS_TIPO
        RS_TIPO rs_tipo = pilaSemantica.get("TIPO")

        // obtener el ámbito
        String ambito = "global";
        if (pilasemantica.get("FUNCION") != null) {
            ambito = pilaSemantica.get("FUNCION").getAmbito();
        }

        // si ya esta en la tabla de símbolos, error
        if (ts.contiene(rs_id.getValor(), ambito) || ts.contiene(rs_id.getValor(), "global")) {
            semantic_error(cur_token);
            System.err.println("La variable '" + rs_id.getValor() + "' ya está definida.");
            return;
        }

        // agregar a la tabla de símbolos
        while (pilaSemantica.top() != rs_tipo) {
            RS_ID rs_id = pilaSemantica.pop();
            Simbolo simbolo = new Simbolo("VAR",  rs_tipo.getTipo_Var(), rs_id.getValor(), ambito);
            ts.insertar();

            // generar código para la declaración de la variable
            generador.genVar(rs_id.getValor(), rs_tipo.getTipo_Var());
        }
        // pop RS_TIPO
        pilaSemantica.pop()
    }

    public void recuerdaOP(String op) {
        RS_OP rs_op = new RS_OP(op);
        pilaSemantica.push(rs_op);
    }

    public void recuerdaVAR(String id) {
        // Verificar si la variable está definida
        if (!ts.contiene(id, ambito)) {
            semantic_error(cur_token);
            System.err.println("La variable '" + id + "' no está definida.");
            return;
        } 
        // Obtener el tipo de la variable
        String tipo = ts.getTipo(id, ambito);

        // Agregar a la pila semántica
        RS_DO rs_do = new RS_DO(id, tipo);

        pilaSemantica.push(rs_do);
    }

    public void recuerdaCONST(Object num) {
        // Agregar a la pila semántica
        RS_DO rs_const = new RS_DO(num, "int", true);
        pilaSemantica.push(rs_const);
    }

    public void evalBinary()
    {
        RS_DO right = pilaSemantica.pop();
        RS_OP op = pilaSemantica.pop();
        RS_DO left = pilaSemantica.pop();

        // Verificar que los tipos sean compatibles
        if (!left.getTipo().equals(right.getTipo())) {
            semantic_error(cur_token);
            System.err.println("Tipos incompatibles en la operación binaria.");
            return;
        }

        // Los DO son constantes?
        if (left.esConstante && right.esConstante) {
            // Evaluar la operación
            Object result = null;
            switch (op.getOp()) {
                case "+":
                    result = (int)left.getValor() + (int)right.getValor();
                    break;
                case "-":
                    result = (int)left.getValor() - (int)right.getValor();
                    break;
                case "*":
                    result = (int)left.getValor() * (int)right.getValor();
                    break;
                case "/":
                    result = (int)left.getValor() / (int)right.getValor();
                    break;
            }

            // Agregar el resultado a la pila semántica
            RS_DO rs_result = new RS_DO(result, "int", true);
            pilaSemantica.push(rs_result);
        } else {
            // generar el código para la operación 
            String var = generador.genBinary(left, right, op);
            // Crear RS_DO de tipo dirección con el lugar donde quedo el resultado, puede ser una variable temporal
            RS_DO rs_result = new RS_DO(var, "int");
        }

        // Guardar el resultado en la pila semántica
        pilaSemantica.push(rs_result);

    }   

    public String generateLabel() {
        return generador.generateLabel();
    }

    public void startIF() {
        RS_IF rs_if = new RS_IF("ELSE" + generateLabel(), "EXITIF" + generateLabel());
        pilaSemantica.push(rs_if);
    }

    public void testIF() {
        RS_DO rs_do = pilaSemantica.pop();
        RS_IF rs_if = pilaSemantica.get("IF");
        // Generar código para la condición
        generador.genTest(rs_do);
        // Generar código para el salto
        generador.genJump(rs_if.getElseLabel())
    }

    public void startELSE() {
        RS_IF rs_if = pilaSemantica.get("IF");
        generador.genJump(rs_if.getExitLabel());
        generador.genLabel(rs_if.getElseLabel());
    }

    public void endIF() {
        RS_IF rs_if = pilaSemantica.pop();
        generador.genLabel(rs_if.getExitLabel());
    }

    public void startWHILE() {
        RS_WHILE rs_while = new RS_WHILE("EXITWHILE" + generateLabel(), "STARTWHILE" + generateLabel());
        pilaSemantica.push(rs_while);
        generador.genLabel(rs_while.getStartLabel());
    }

    public void testWHILE() {
        RS_DO rs_do = pilaSemantica.pop();
        RS_WHILE rs_while = pilaSemantica.get("WHILE");
        // Generar código para la condición
        generador.genTest(rs_do);
        // Generar código para el salto
        generador.genJump(rs_while.getExitLabel())
    }

    public void endWHILE() {
        RS_WHILE rs_while = pilaSemantica.pop();
        generador.genJump(rs_while.getStartLabel());
        generador.genLabel(rs_while.getExitLabel());
    }

    public void testBreak() {
        // Verificar que esté dentro de un bucle
        RS_WHILE rs_while = pilaSemantica.get("WHILE");
        if (rs_while == null) {
            semantic_error(cur_token);
            System.err.println("'break' fuera de contexto válido (se requiere bucle).");
        } 
        // Generar código para el salto
        generador.genJump(rs_while.getExitLabel());
    }

    public void testContinue() {
        // Verificar que esté dentro de un bucle
        RS_WHILE rs_while = pilaSemantica.get("WHILE");
        if (rs_while == null) {
            semantic_error(cur_token);
            System.err.println("'continue' fuera de contexto válido (se requiere bucle).");
        } 
        // Generar código para el salto
        generador.genJump(rs_while.getStartLabel());
    }

    public void startFunc() {   
        RS_FUNC rs_func = new RS_FUNC("FUNC" + generateLabel());
        RS_ID rs_id = pilaSemantica.pop();
        RS_TIPO rs_tipo = pilaSemantica.pop();

        ts.insertar(rs_id.getValor(), rs_tipo.getTipo(), "global");

        pilaSemantica.push(rs_func);
    }

    public void endFunc() {
        RS_FUNC rs_func = pilaSemantica.pop();
    }

    public void incrementarValor() {
        RS_DO rs_do = pilaSemantica.pop();
        RS_OP rs_op = pilaSemantica.pop();
        // Verificar que sea una variable
        if (!rs_do.getTipo().equals("int")) {
            semantic_error(cur_token);
            System.err.println("Incremento/decremento solo aplicable a variables de tipo entero.");
        }
        // Generar código para la operación
        generador.genIncrement(rs_do, rs_op);
        // Crear RS_DO de tipo dirección con el lugar donde quedo el resultado, puede ser una variable temporal
        RS_DO rs_result = new RS_DO(rs_do.getValor(), "int");
        // Guardar el resultado en la pila semántica
        pilaSemantica.push(rs_result);
    }

    public void asignarValor() {
        RS_DO rs_do = pilaSemantica.pop();
        RS_ID rs_id = pilaSemantica.pop();
        // Verificar que la variable esté definida
        if (!ts.contiene(rs_id.getValor(), ambito)) {
            semantic_error(cur_token);
            System.err.println("La variable '" + rs_id.getValor() + "' no está definida.");
            return;
        }
        // Verificar que los tipos sean compatibles
        if (!ts.getTipo(rs_id.getValor(), ambito).equals(rs_do.getTipo())) {
            semantic_error(cur_token);
            System.err.println("Tipos incompatibles en la asignación.");
            return;
        }
        // Generar código para la asignación
        generador.genAssign(rs_id.getValor(), rs_do);
    }

:};



/* Declaración de terminales*/
terminal ID, TRUE, FALSE, EQ, PLUS, MINUS, TIMES, DIV, SEMI, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, EQ_EQ, GT, LT, NOT_EQ, PLUS_PLUS, MINUS_MINUS, IF, ELSE, WHILE, TYPE_INT, TYPE_LONG, TYPE_SHORT, TYPE_CHAR, VOID, BREAK, CONTINUE, INT, FLOAT;
/* No terminales con tipos */
non terminal String tipo_var;

/* No terminales sin tipo específico */
non terminal programa, expr, instruccion, global_decl_list, globales, bloque, estru_control, funciones, funcion, parametro_list, if, else, while, variable, id_list, asignacion, op_asignacion, op_incremento, literal, op_relacional, number, next_id_list, op_aritmetico;


/* Precedence and associativity declarations */
precedence left EQ_EQ, NOT_EQ;
precedence left GT, LT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
precedence left PLUS_PLUS, MINUS_MINUS;
precedence right EQ; // Added precedence for assignment operator

/* Start with the programa non-terminal */
start with programa;

/* The grammar rules for C subset */

programa ::= globales 
           ;

globales ::= global_decl_list funciones
           ;


global_decl_list ::= global_decl_list variable 
                   | variable
                   ;                 

funciones ::= funciones funcion
              | funcion 
              ;


tipo_var ::= TYPE_INT {: RESULT = "int"; :}
           | TYPE_LONG {: RESULT = "long"; :}
           | TYPE_SHORT {: RESULT = "short"; :}
           | TYPE_CHAR {: RESULT = "char"; :}
           ;

variable ::= tipo_var:tipo {: recuerdaTipo(tipo) :} ID:id {: recuerdaID(id); :} next_id_list SEMI {: insertarTS() :}
           | tipo_var id_list error {: report_error("Missing semicolon in variable declaration."); :}
           ;

next_id_list ::= COMMA ID:id {: recuerdaID(id); :} next_id_list 
               | /* empty */
               ;

funcion ::= tipo_var:tipo {: recuerdaTipo(tipo) :} ID:id {: recuerdaID(id); :} LPAREN {: startFunc() :} parametro_list  RPAREN LBRACKET bloque RBRACKET {: endFunc() :}
            | VOID {: recuerdaTipo('Void') :} ID:id {: recuerdaID(id); :} LPAREN {: startFunc() :} parametro_list  RPAREN LBRACKET bloque RBRACKET {: endFunc() :}
            | tipo_var  error bloque RBRACKET {: report_error("Invalid function declaration."); :}
            ;

parametro_list ::= tipo_var:tipo {: recuerdaTipo(tipo):} ID:id {: recuerdaID(id):} COMMA {: insertarTS() :} parametro_list 
                 | tipo_var:tipo {: recuerdaTipo(tipo):}  ID:id {: recuerdaID(id) :} {: insertarTS() :}
                 | /* empty */
                 | error {: report_error("Error in parameter list."); :}
                 ;

bloque ::= instruccion
         | instruccion bloque
         ;


instruccion ::= estru_control
              | variable
              | asignacion SEMI
              | BREAK SEMI {: testBreak(); :}
              | CONTINUE SEMI {:testContinue(); :}
              | error {: report_error("Invalid instruction."); :}
              ;

estru_control ::= if
                | while
                ;

if ::= IF LPAREN expr RPAREN {: testIF() :} LBRACKET bloque RBRACKET else {: startELSE() :}
     | IF error bloque RBRACKET else {: report_error("Invalid expression in 'if' condition."); :}

     ;

else ::= ELSE LBRACKET bloque RBRACKET {: endIF() :}
       | ELSE error {: report_error("Invalid 'else' statement."); :}
       | /* empty */
       ;


while ::= WHILE {: startWHILE() :} LPAREN expr RPAREN {: testWHILE() :} LBRACKET bloque RBRACKET {: endWHILE() :}
        | WHILE error bloque RBRACKET {: report_error("Invalid 'while' loop condition."); :}
        ;


asignacion ::= ID:id {: recuerdaID(id) :} op_asignacion:op expr {: asignarValor(); :}
             | ID:id {: recuerdaID(id) :} op_incremento:op {: incrementarValor(op); :}
             | ID op_asignacion error {: report_error("Invalid assignment expression."); :}
             ;

op_asignacion ::= EQ:op {: RESULT = op; :}
                ;

op_incremento ::= PLUS_PLUS:op {: RESULT = op; :}
                | MINUS_MINUS:op {: RESULT = op; :}
                ;

expr ::= literal
    | literal op_aritmetico:op {: recuerdaOP(op) :} literal {: evalBinary(); :}
    | literal op_relacional:op {: recuerdaOP(op) :} literal {: evalBinary(); :}
    ;

literal ::= TRUE {: recuerdaCONST('true'); :}
          | FALSE {: recuerdaCONST('false'); :}
          | number:num {: recuerdaCONST(num); :}
          | ID:id {: recuerdaVAR(id); :}
          ;

op_relacional ::= EQ_EQ
                | GT
                | LT
                | NOT_EQ
                ;


op_aritmetico ::= PLUS
                | MINUS
                | TIMES
                | DIV
                ;


number ::= INT
         | FLOAT
         ;