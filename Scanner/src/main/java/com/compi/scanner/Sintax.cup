/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package com.compi.scanner;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import com.compi.scanner.semantico.*;
import com.compi.scanner.traductor.*;

/* Clases auxiliares */
action code {:
    public class ExprValue {
        public boolean esConstante;
        public Object valor;
        public String tipo; // "int", "float", etc.

        public ExprValue(boolean esConstante, Object valor, String tipo) {
            this.esConstante = esConstante;
            this.valor = valor;
            this.tipo = tipo;
        }
    }

    public class Pair<K, V> {
        private K key;
        private V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() { return key; }
        public V getValue() { return value; }
    }
:}

parser code {:
    private Symbol sym;

    public void syntax_error(Symbol sym) {
        System.err.println("Error sintáctico en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void unrecovered_syntax_error(Symbol sym) {
        System.err.println("Error irreparable en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void semantic_error(Symbol sym) {
        System.err.println("Error semántico en línea " + (sym.left + 1) + ", columna " + (sym.right + 1) + ": " + sym.value);
    }

    public void report_error(String message) {
        System.err.println(message);
    }
        
    public Symbol getS(){
        return this.sym;
    };

    public Generador generador = new Generador();

    // Para manejo de bucles
    private int contadorBucles = 0;

    public void iniciarBucle() {
        contadorBucles++;
    }

    public void finalizarBucle() {
        contadorBucles--;
    }

    public boolean dentroDeBucle() {
        return contadorBucles > 0;
    }

    // Métodos para la tabla de símbolos
    private TablaSimbolos ts = new TablaSimbolos();
    public PilaSemantica pilaSemantica = new PilaSemantica();
    public PilaSemantica pilaSemantica2 = new PilaSemantica();

    public void imprimirTablasSimbolos() {
        ts.imprimirTablas();
    }

    // Para manejo del ambito
    private String ambito = "global";
    public void setAmbito (String amb){
        //System.out.println("dentro del setAmbito" + amb);
        ambito = amb;
    }

    // Funciones adicionales
    public void insertarConstante (String tipo, String id, Object valor){
        //System.out.println("tipo> "+tipo+", id> "+id+", valor> "+valor);
        String mensaje = ts.insertarConstante(new Simbolo("CONST", tipo, id, valor, ambito));
        if (mensaje != null){
            semantic_error (cur_token);
            System.err.println(mensaje);
        } 
        pilaSemantica.clear ();
        //pilaSemantica.print ();
        //System.out.println("despues del insert constante\n");
    }

    public void insertarVariables (){
        String tipo = pilaSemantica.buscarTipoVar ();
        if (tipo!=null){
            while (!pilaSemantica.isEmpty() && pilaSemantica.get(pilaSemantica.size() - 1).getTipo().equals("")) {
                RegistroSemantico registro = pilaSemantica.pop_end();
                String mensaje = ts.insertarVar (new Simbolo ("VAR", tipo, registro.getId(), ambito));
                if (mensaje != null){
                    semantic_error (cur_token);
                    System.err.println(mensaje);
                } 
            }
        }
        pilaSemantica.pop_end ();
        pilaSemantica.clear ();
        //pilaSemantica.print ();
        //System.out.println("despues del insert variable\n");
    }

    public void insertarFuncion (String tipo, String id){
        if (!ts.existeFuncion (id)){
            ts.insertarFuncion (new Simbolo ("FUNCION", tipo, id));
            setAmbito (id);
        } else {
            semantic_error (cur_token);
            System.err.println("La función'" + id + "' ya está definida.");
            setAmbito (null);
        }
    }

    public void verificarVariableDefinida(String id, Object valor) {
        //System.out.println("dentro del verificar, id>" + id + ", ambito> "+ambito);
        if (!ts.contiene(id, ambito)) {   
            semantic_error (cur_token);
            System.err.println("La variable '" + id + "' no está definida.");
            String tipo = pilaSemantica.buscarTipoVar ();
            if (tipo!=null) {
                if (valor != null) {
                    if (ambito != null)  ts.insertarVar (new Simbolo ("VAR", tipo, id, valor, ambito));
                    else ts.insertarVar (new Simbolo ("VAR", tipo, id, valor));
                } else {
                    if (ambito != null)  ts.insertarVar (new Simbolo ("VAR", tipo, id, ambito));
                    else ts.insertarVar (new Simbolo ("VAR", tipo, id));
                }
            }else System.err.println("La variable '" + id + "' no se pudo insertar a la tabla de simbolos porque no tiene un tipo especificado.");
        } 
    }

    public void insertarParametros (){
        int cantParametros = 0;
        //System.out.println("dentro del insertarParametros, ambito> "+ambito);
        //pilaSemantica.print ();
        while (!pilaSemantica.isEmpty() && pilaSemantica.get(pilaSemantica.size() - 1).getTipo().equals("PARAMETRO")) {
            RegistroSemantico registro = pilaSemantica.pop_end();
            String mensaje = ts.insertarVar (new Simbolo (registro.getTipo(), registro.getTipo_Var(), registro.getId(), ambito));
            if (mensaje != null){
                semantic_error (cur_token);
                System.err.println(mensaje);
            } else cantParametros ++;
        }
        Simbolo funcion = ts.obtenerSimbolo (ambito);
        if (funcion!=null)funcion.setValor (cantParametros);
    }


    public void asignacion (String id, String op, String expr) {
        if (ts.contiene(id, ambito)) {   
            Simbolo simbolo = ts.obtenerSimbolo (id);
            if (expr == null){  // es una op_incremento, se valida que la var este inicializada
                if (simbolo.getValor() != null){  // si esta inicializada
                    generador.opIncremento (id, op);
                } else {
                    semantic_error (cur_token);
                    System.err.println("La variable '" + id + "' no está inicializada por lo que no se puede ejecutar la operación de incremento.");
                }
            } else {

            }
        } else {
            semantic_error (cur_token);
            System.err.println("La variable '" + id + "' no está definida.");
        }
    }

:};



/* Declaración de terminales*/
terminal ID, MOD, STRING, CONST, WRITE, READ, TRUE, FALSE, EQ, PLUS, MINUS, TIMES, DIV, SEMI, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, COLON, EQ_EQ, GT_EQ, GT, LT_EQ, LT, NOT_EQ, PLUS_EQ, MINUS_EQ, TIMES_EQ, DIV_EQ, PLUS_PLUS, MINUS_MINUS, OR, AND, NOT, IF, ELSE, FOR, WHILE, SWITCH, CASE, DEFAULT, TYPE_INT, TYPE_LONG, TYPE_SHORT, TYPE_CHAR, VOID, BREAK, CONTINUE, DO, RETURN, INT , FLOAT, CHAR;

/* No terminales con tipos */
non terminal String tipo_var;
non terminal ExprValue arit_exp;

/* No terminales sin tipo específico */
non terminal programa, expr, read, read_parameter, write_parameter, write, case_end, instruccion , global_decl_list, expr_list, global_decl, globales, bloque, estru_control, funciones, funcion, parametro_list, if, else, for, while, switch, case_list, constante, variable, id_list, asignacion, op_asignacion, op_incremento, literal, bool_expr, bool_term, bool_factor, rel_expr, op_relacional, term, factor, number, next_id_list;

/* Precedence and associativity declarations */
precedence left OR, AND;
precedence left EQ_EQ, NOT_EQ;
precedence left GT, LT, GT_EQ, LT_EQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence right NOT;
precedence left PLUS_PLUS, MINUS_MINUS;
precedence left EQ, PLUS_EQ, MINUS_EQ, TIMES_EQ, DIV_EQ;


/* Start with the programa non-terminal */
start with programa;

/* The grammar rules for C subset */

programa ::= globales {: imprimirTablasSimbolos(); generador.generarArchivo(); :}
           ;

globales ::= global_decl_list funciones
           ;


global_decl_list ::= global_decl_list global_decl 
                   | global_decl
                   ;                 

global_decl ::= variable {: ts.global (); :}
              | constante {: ts.global (); :}
              | error {: report_error("Error in global declaration."); :}
              ;

funciones ::= funciones funcion
              | funcion {: generador.declararGlobales(ts); :}
              ;

instruccion ::= estru_control
              | constante
              | variable
              | asignacion SEMI
              | BREAK SEMI {: if (!dentroDeBucle()) semantic_error(cur_token); :}
              | read SEMI
              | write SEMI
              | CONTINUE SEMI {: if (!dentroDeBucle()) semantic_error(cur_token); :}
              | DO SEMI 
              | RETURN expr SEMI
              | RETURN SEMI
              | error {: report_error("Invalid instruction."); :}
              ;

read ::= READ LPAREN read_parameter RPAREN 
       | READ LPAREN RPAREN
       | READ error {: report_error("Invalid 'read' parameters."); :}
       ;

read_parameter ::= ID COMMA read_parameter
                 | ID
                 ;

write ::= WRITE LPAREN write_parameter RPAREN
        | WRITE error {: report_error("Invalid 'write' parameters."); :}
        ;


write_parameter ::= expr COMMA write_parameter
                  | expr
                  ;


bloque ::= instruccion
         | instruccion bloque
         ;


expr_list ::= expr COMMA expr_list
            | expr
            | /* empty */
            | error {: report_error("Error in expression list."); :}
            ;

estru_control ::= if
                | for
                | while
                | switch
                ;


funcion ::= tipo_var:tipo ID:id {: insertarFuncion (tipo.toString(), id.toString()); :} 
                LPAREN parametro_list {: insertarParametros (); :} RPAREN LBRACKET bloque RBRACKET
            | VOID:tipo ID:id LPAREN parametro_list RPAREN {: setAmbito (id.toString()); :}  LBRACKET bloque RBRACKET {:
                //pilaSemantica.push_init(new RegistroSemantico ("FUNCION", tipo.toString(), id.toString()));
                // falta meter funcion y sus parametros a ts
                // pilaSemantica.print ();
            :}
            | tipo_var ID LBRACKET error bloque RBRACKET {: report_error("Invalid function declaration."); :}
            | VOID ID LBRACKET error bloque RBRACKET {: report_error("Invalid function declaration."); :}
            ;

parametro_list ::= tipo_var:tipo ID:id COMMA parametro_list {: 
                    pilaSemantica.push_end (new RegistroSemantico ("PARAMETRO", tipo, id.toString(), ambito)); 
                :}
                 | tipo_var:tipo ID:id {: 
                    pilaSemantica.push_end (new RegistroSemantico ("PARAMETRO", tipo, id.toString(), ambito)); 
                :}
                 | /* empty */
                 | error {: report_error("Error in parameter list."); :}
                 ;


if ::= IF LPAREN expr RPAREN {: /*System.out.println("getAmbito>"+ambito); */generador.estructuraIf (pilaSemantica); :} LBRACKET bloque RBRACKET else
     | IF error bloque RBRACKET else {: report_error("Invalid expression in 'if' condition."); :}
     | IF LPAREN expr RPAREN error {: report_error("Invalid 'if' statement."); :}
     ;

else ::= ELSE LBRACKET bloque RBRACKET
       | ELSE error {: report_error("Invalid 'else' statement."); :}
       | /* empty */
       ;

for ::= FOR LPAREN asignacion SEMI expr SEMI asignacion RPAREN LBRACKET {: iniciarBucle(); :} bloque RBRACKET {: finalizarBucle(); :}
        | FOR error bloque RBRACKET {: report_error("Invalid 'for' loop condition."); finalizarBucle();  :} 
        | FOR LPAREN asignacion SEMI expr SEMI asignacion RPAREN error {: report_error("Invalid 'for' loop condition."); :}
       ;

while ::= WHILE LPAREN expr RPAREN LBRACKET {: iniciarBucle(); :}  bloque RBRACKET {: finalizarBucle(); :}
        | WHILE error bloque RBRACKET {: report_error("Invalid 'while' loop condition."); finalizarBucle();  :}
        | WHILE LPAREN expr RPAREN error {: report_error("Invalid 'while' loop condition."); :}
         ;

switch ::= SWITCH LPAREN arit_exp RPAREN LBRACKET case_list case_end RBRACKET
        | SWITCH error case_list case_end RBRACKET {: report_error("Invalid 'switch' statement."); :}
        | SWITCH LPAREN arit_exp RPAREN error {: report_error("Invalid 'switch' statement."); :}
         ;

case_list ::= CASE arit_exp COLON bloque
            | CASE arit_exp COLON bloque case_list
            | CASE error {: report_error("Invalid 'case' statement."); :}
            ;

case_end ::= DEFAULT COLON bloque
           | DEFAULT error {: report_error("Invalid 'default' statement."); :}
           | /* empty */
           ;

constante ::= CONST tipo_var:tipo ID:id EQ expr:valor SEMI {:
                insertarConstante(tipo, id.toString(), valor);
            :}
            | CONST tipo_var ID EQ expr error {: report_error("Missing semicolon in constant declaration."); :}
            ;

variable ::= tipo_var:tipo id_list SEMI{:
                pilaSemantica.push_init(new RegistroSemantico (tipo));
                insertarVariables ();
            :}
           | tipo_var id_list error {: report_error("Missing semicolon in variable declaration."); :}
           ;


tipo_var ::= TYPE_INT {: RESULT = "int"; :}
           | TYPE_LONG {: RESULT = "long"; :}
           | TYPE_SHORT {: RESULT = "short"; :}
           | TYPE_CHAR {: RESULT = "char"; :}
           ;


id_list ::= ID:id next_id_list{:
                pilaSemantica.push_end (new RegistroSemantico (id.toString()));
            :}
            ;

next_id_list ::= COMMA ID:id next_id_list {:
                    pilaSemantica.push_end (new RegistroSemantico (id.toString()));
                :}
               | /* empty */
               ;


asignacion ::= ID:id op_asignacion:op expr:valor{:
                verificarVariableDefinida(id.toString(), valor);
                // falta código adicional para manejo de asignación
             :} 
             | ID:id op_incremento:op{:
                asignacion (id.toString(), op.toString(), null);

                // falta código adicional para manejo de asignación
             :} 
             | ID op_asignacion error {: report_error("Invalid assignment expression."); :}
             ;

op_asignacion ::= EQ:op {: RESULT = op; :}
                | PLUS_EQ:op {: RESULT = op; :}
                | MINUS_EQ:op {: RESULT = op; :}
                | TIMES_EQ:op {: RESULT = op; :}
                | DIV_EQ:op {: RESULT = op; :}
                ;

op_incremento ::= PLUS_PLUS:op {: RESULT = op; :}
                | MINUS_MINUS:op {: RESULT = op; :}
                ;

expr ::= expr:left PLUS:op expr:right 
       | expr:left MINUS:op expr:right
       | expr:left TIMES:op expr:right
       | expr:left DIV:op expr:right
       | expr:left MOD:op expr:right
       | expr:left AND expr:right {: 
            // Implementar lógica para operadores lógicos
        :}
       | expr:left OR expr:right {:  :}
       | NOT expr:exp {: :}
       | expr:left op_relacional:op expr:right {: /*
            System.out.println("l> "+left);
            System.out.println("operador> "+op);
            System.out.println("r> "+right);*/
            //pilaSemantica.print ();
            //System.out.println("DESPUESITO ");
        :}
       | LPAREN expr:exp RPAREN {: :}
       | ID:id LPAREN expr_list RPAREN {: 
            // Llamada a función
           
        :}
       | ID:id {: 
            verificarVariableDefinida(id.toString(), null);
            pilaSemantica.push_end (new RegistroSemantico (true, "VAR", id.toString()));
            RESULT = id;
        :}
       | literal:lit {: 
            pilaSemantica.push_end (new RegistroSemantico (true, "CONST", lit.toString()));
            RESULT = lit;
        :}
       | number:num {: 
            pilaSemantica.push_end (new RegistroSemantico (true, "CONST", num.toString()));
            RESULT = num;
        :}
       ;

// Implementar lógica similar a 'expr' para constant folding
arit_exp ::= arit_exp:left PLUS arit_exp:right {: RESULT = new ExprValue(false, null, null); :} 
           | arit_exp:left MINUS arit_exp:right {: RESULT = new ExprValue(false, null, null); :}
           | arit_exp:left TIMES arit_exp:right {: RESULT = new ExprValue(false, null, null); :}
           | arit_exp:left DIV arit_exp:right {: RESULT = new ExprValue(false, null, null); :}
           | arit_exp:left MOD arit_exp:right {: RESULT = new ExprValue(false, null, null); :}
           | LPAREN arit_exp:exp RPAREN {: RESULT = exp; :}
           | ID:id {: 
                verificarVariableDefinida(id.toString(), null);
                Simbolo simbolo = ts.obtenerSimbolo(id.toString());
                if (simbolo != null && simbolo.esConstante()) {
                    RESULT = new ExprValue(true, simbolo.getValor(), simbolo.getTipo_var());
                } else {
                    RESULT = new ExprValue(false, null, null);
                }
            :}
           | number:num {: RESULT = new ExprValue(true, num, "int"); :}
           ;

op_relacional ::= EQ_EQ:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                | GT_EQ:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                | GT:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                | LT_EQ:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                | LT:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                | NOT_EQ:op {: pilaSemantica.push_end (new RegistroSemantico (op.toString())); RESULT = op; :}
                ;

literal ::= CHAR:c {: RESULT = c.toString(); :}
          | STRING:s {: RESULT = s.toString(); :}
          | TRUE {: RESULT = true; :}
          | FALSE {: RESULT = false; :}
          ;

number ::= INT:n {: RESULT = n; :}
         | FLOAT:n {: RESULT = n; :}
         ;